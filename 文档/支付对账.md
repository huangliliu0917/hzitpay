​		

### 什么是对账

传统的对账就是核对账目，是指在会计核算中，为保证账簿记录正确可靠，对账簿中的有关数据进行检查和核对的工作。在银行或者第三方支付中，对账其实是对一定周期内的交易进行双方确认的过程，一般都是在第二天银行或者第三方支付公司对前一日交易进行清分，生成对账单供平台商户下载，并将应结算款结算给平台商户。在往下一层，在互联网金融行业或者电商行业中，对账其实就是确认在固定周期内和支付提供方（银行和第三方支付）的交易、资金的正确性，保证双方的交易、资金一致正确。

广义的对账，所有跨应用的数据交互，理论上都应该进行对账。所以对账也可以分为信息流对账，资金流对账。信息流对账也一般用在自己内部系统的对账，比如支付系统的支付数据和业务系统的业务数据进行对账，保证资金交易和业务交易的一致性。资金流对账也就是支付系统和银行或者第三方支付系统之间的资金交易对账。



**对账方式**

- 单向对账：一般拿第三方支付机构或银行流水，与自己系统进行对账，防止出现掉单问题；	

  掉单：用户扣款成功，但是状态确没有成功，我们系统支付没有成功，银行的系统成功。

  ​	1.网络原因，可能没有收到回调。

  ​	解决：调用1.支付查询接口。2.对账

  



- 双向对账：两个应用间的流水进行双向核对，如订单与财务系统，既要保证财务系统支付成功的记录，订单系统也是成功的；也要确保订单系统记录成功的记录，财务系统也成功。

​		我们一般采用双向对账的方式进行对账



**对账相关的问题**

不同系统日切点不一致问题：滚动对账
差错处理：补账，补偿（退款）



### 相关概念

**轧帐和平帐**

每一笔交易，都要做到各参与者的记录能够吻合，没有偏差。对账系统的工作，是发现有差异的记录，即轧帐；然后通过人工或者自动的方式，解决这些差异，即平帐。



**长款和漏单**

在以平台交易为基准的情况下和银行对账，发现周期内的交易，平台有此订单而第三方支付中没有订单，成为平台长款。平台长款一般是由于用户在支付的时候跨天的情况，比如用户在23:58分创建了订单，在第二天的凌晨00:03分进行了支付。在以银行交易为基准的情况下对账，银行有此订单而平台无此订单，即为平台漏单。平台漏单很少见，一般直接转人工处理。



**账户体系**

在一般的支付体系中会分为登录账户和支付账户，支付账户指用户在支付系统中用于交易的资金所有者权益的凭证；登录账号指用户在系统中登录的凭证和个人信息。一个用户可以有多个登录账户，一个登录账户可以有多个支付账户，比如零钱账户、储值卡账户等。一般来说，支付账户不会在多个登录账户之间共用。对账的交易一般都是支付账户参与交易。



**交易与账户**

账户设置，一般是从交易开始的。 交易的实现必须有账户的支持，账户是交易的基本构成元素。 从支付系统的角度，交易中涉及到的资金流是资金从一个账户流向另一个账户。 发起交易的一方，被称之为交易主体，他可以是一个人，也可以是一个机构。



**清算和结算**

清算主要是指不同银行间的货币收付，可以认为是结算进行之前，发起行和接收行对支付指令的发送、接收、核对确认，其结果是全面交换结算工具和支付信息，并建立最终结算头寸。

结算是指将清算过程产生的待结算头寸分别在发起行、接收行进行相应的会计处理，完成资金转移，并通知收付双方的过程。当前，大多数银行结算业务的完成主要通过两类账户：一是银行间互相开立的代理账户，二是开立在央行、独立金融机构如银联、或者第三方支付机构的账户。

清算：计算各方应收应付钱款的时间与金额。结算：根据清算的结果在指定的时间对各方进行实际的资金转移操作



**资金池**

用户备付资金（如充值）统一放在企业的银行账户中，企业可以随意支配这些资金，即为资金池。与之对应的是第三方托管，用户备付资金是放在企业在第三方支付机构为用户开设的虚拟账户中，企业无法随意取出这些资金。现在互联网金融全面要求接入银行存管，就是银行会为每个用户创建一个资金账户来保护用户的资金，互联金融公司不能随意划拨这些资金账户中的金额。



## 对账系统



![](C:\Users\Administrator\Desktop\项目\imge\recon.webp.jpg)





对账系统的设计阶段，将对账系统分为四个模块，每个模块的负责自己的职能。

- 文件获取模块：下载或者读取各渠道对账文件
- 文件解析模块：创建不同的解析模板，根据渠道和文件类型获取对应的解析模板进行解析
- 对账处理模块：对账的业务逻辑处理
- 差错处理模块：处理差错池中的订单



一般会设计一个定时任务，每天固定的时间点触发，定时驱动调度类分别调用四个模块来处理对账。也有的银行会主动的推送对账单，再通过http回调来触发对账流程。



一、流程：

1、从上游渠道（银行、银联等金融机构）获取对账文件，程序逐行解析入库；
 2、在程序处理中，以上游对账文件的表为基准，程序逐行读取并与我们系统的交易记录对比账务记录（有账务系统情况下，合理方案应该是于账务记录）对比，查找出差异记录；
 3、以我们系统的交易记录对比账务记录为基准，程序逐行读取与上游对账文件对比，查找出差异记录。

二、缺陷：

1、对账过程中查询相关数据，如果数据量巨大，对数据库性能影响较大，而且对账逻辑扩展极为麻烦；
 2、逐行比对算法效率较低，但算法上并无好的优化余地。如果采用数据库INTERSECT、MINUS对数据库压力也高；
 3、在业务量大的情况下（例如有上百家上游渠道需要对，每一家都有几十万条交易记录），对账服务器及数据库服务器负荷较高。即便采用读写分离，对账时候使用读库，压力一样很大；
 4、导入批量文件，逐行入库效率较为低下（每一次都需要建立网络连接、关闭连接）。



三、改进：

1、涉及网络传输的，尽量采用批量方式操作，减少网络消耗及时间消耗；
 2、使用Redis等NOSQL数据库，降低数据库服务器的压力。同时在扩展上也容易，一台Redis服务器不够，可以无限制增加用于对账用的服务器；
 3、使用Redis的set集合的sdiff功能，利用Redis sdiff算法的高性能，比对上游记录和我方记录的差异。







支付宝接口：https://docs.open.alipay.com/api_15/alipay.data.dataservice.bill.downloadurl.query



redis实现对账





```
@Test
void contextLoads() {
     //流水号            金额  状态
    //GM002215120800002,0.01,3",  "GM002215120800003,0.01,3

    //将本地t_PAy_order中的数据放入redis
    redisUtil.sadd("{account}:localSet", "GM002215120800002,0.01,3","GM002215120800003,0.01,3");

    //流水号            金额  状态
    //GM002215120800002,0.01,3",  "GM002215120800003,0.01,3
    //将支付宝的交易数据从t_recon_temp中的数据放入redis
    redisUtil.sadd("{account}:outerSet", "GM002215120800002,0.01,3","GM002215120800003,0.01,1");


    //进行2个集合的比对，得出交集union，将交集放入key”{account}:union”中
    redisUtil.sinterstore("{account}:union", "{account}:localSet", "{account}:outerSet");
    //union = GM002215120800002,0.01,3

    //localSet和outerSet分别与交集进行比较，得出差集{account}:localDif
    redisUtil.sdiffstore("{account}:localDiff", "{account}:localSet", "{account}:union");
    //localDiff = GM002215120800003,0.01,3

    redisUtil.sdiffstore("{account}:outerDiff", "{account}:outerSet", "{account}:union");
    //outerDiff = GM002215120800003,0.01,1


    Set<String> set = redisUtil.smembers("{account}:localDiff");
    if(set!=null){
        Iterator<String> it = set.iterator();
        while (it.hasNext()) {
            String str = it.next();
            System.out.println("localDiff:"+str);
        }
    }

    Set<String> set1 = redisUtil.smembers("{account}:outerDiff");

    if(set1!=null){
        Iterator<String> it = set1.iterator();
        while (it.hasNext()) {
            String str = it.next();
            System.out.println("outerDiff:"+str);
        }
    }

}
```





